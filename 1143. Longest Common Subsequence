<-- Problem Statement -->
Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.
A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
For example, "ace" is a subsequence of "abcde".
A common subsequence of two strings is a subsequence that is common to both strings.

CODE :

class Solution {
    int memo(int i , int j , string text1 , string text2 , vector<vector<int>>& dp){
        int m = text1.size();
        int n= text2.size();
        if(i<0 || j<0) return 0;
        if(dp[i][j]!=-1) return dp[i][j];

        if(text1[i]== text2[j]){
            dp[i][j] = 1+ memo(i-1 , j-1 , text1 , text2 ,dp);
        }else {
            dp[i][j]= max(memo(i-1,j , text1 , text2 , dp) , memo(i,j-1 , text1 , text2 , dp));
        }
        return dp[i][j];
    }
    int tabulationApproach( string text1 , string text2){
        int m = text1.size();
        int n= text2.size();
        vector<vector<int>>dp(m+1 , vector<int>(n+1 , 0)); // dp[i][j] will the store the common subsequnce upto length i in text1 and j in text 2
        for(int i=1;i<=m;i++){
           for(int j=1;j<=n;j++){
                if(text1[i-1]==text2[j-1]){
                    dp[i][j] = 1+ dp[i-1][j-1];
                }else{
                    dp[i][j]= max(dp[i-1][j] , dp[i][j-1]);
                }
           }
        }
        return dp[m][n];
    }
     
    int spaceOptimised(string text1 , string text2){
        int m = text1.size();
        int n= text2.size();
       // according to striver's logic 
       // if you see dp[i][...] in the tabulation code and dp[i-1][..] then you can replace dp[i] with curr and dp[i-1] with prev , to optimise( space)  it even further .
        vector<int> prev(n + 1, 0);
        vector<int> curr(n + 1, 0);
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    curr[j] = 1 + prev[j - 1];
                } else {
                    curr[j] = max(prev[j], curr[j - 1]);
                }
            }
            prev = curr;
        }
        return prev[n];
    }
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n= text2.size();
        /* MEMOIZED
        vector<vector<int>>dp(m , vector<int>(n , -1));
        return memo(m-1 , n-1 , text1 ,text2 , dp);
        */
        /* TABULATION 
        return tabulationApproach(text1 , text2);
        */

        return spaceOptimised(text1 , text2);

    }
};
