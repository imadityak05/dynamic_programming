#include <vector>
#include <iostream>
using namespace std;

const int MAX = 201; // max path length (m + n), adjust if needed

// dp[i][j][zero][ones] = -1 means unvisited
// 0 means false, 1 means true
int memo(int i, int j, int zero, int ones, 
         const vector<vector<int>>& grid, 
         vector<vector<vector<vector<int>>>>& dp) {
    if (i < 0 || j < 0) return 0;

    if (grid[i][j] == 0) zero++;
    else ones++;

    if (i == 0 && j == 0) 
        return zero == ones ? 1 : 0;

    if (dp[i][j][zero][ones] != -1) 
        return dp[i][j][zero][ones];

    int up = memo(i - 1, j, zero, ones, grid, dp);
    int left = memo(i, j - 1, zero, ones, grid, dp);

    dp[i][j][zero][ones] = (up || left) ? 1 : 0;
    return dp[i][j][zero][ones];
}

bool isThereAPath(const vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    int maxCount = m + n; // max zeros or ones possible on path

    // Initialize dp with -1 (unvisited)
    vector<vector<vector<vector<int>>>> dp(
        m, vector<vector<vector<int>>>(
            n, vector<vector<int>>(
                maxCount, vector<int>(maxCount, -1)
            )
        )
    );

    return memo(m - 1, n - 1, 0, 0, grid, dp) == 1;
}

// Example usage
int main() {
    vector<vector<int>> grid = {
        {0, 1, 0, 0},
        {0, 1, 0, 0},
        {1, 0, 1, 0}
    };

    if (isThereAPath(grid)) {
        cout << "Path with equal number of 0s and 1s exists." << endl;
    } else {
        cout << "No such path exists." << endl;
    }

    return 0;
}
