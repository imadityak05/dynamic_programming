<-- Problem Statement -->
Given a string s, find the longest palindromic subsequence's length in s.
A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

CODE:

class Solution {
    int memo(int i , int j , string s , string t , vector<vector<int>> & dp){
        if(i<0 || j < 0 ) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        if(s[i]== t[j]) dp[i][j] = 1+ memo(i-1 ,j-1 ,s , t, dp);
        else dp[i][j]= max(memo(i-1 ,j , s ,t , dp)  , memo(i , j-1 , s, t, dp));
        return dp[i][j];
    }
    int tabulation(string s){
        int m= s.length();
        string t  = s;
        reverse(t.begin() ,t.end());
        vector<vector<int>> dp( m+1 , vector<int>(m+1,0));

        for(int i=1;i<=m;i++){
            for(int j=1;j<=m;j++){
                if(s[i-1]==t[j-1]){
                    dp[i][j] = 1+ dp[i-1][j-1];
                }else{
                    dp[i][j] = max( dp[i-1][j] , dp[i][j-1]);
                }
            }
        }
        return dp[m][m];
    }
    int spaceOptimised(string s){
        int m= s.length();
        string t  = s;
        reverse(t.begin() ,t.end());
        vector<int>curr(m+1 , 0);
        vector<int>prev (m+1 , 0);

        for(int i=1;i<m+1;i++){
            for(int j=1;j<m+1;j++){
                if(s[i-1]==t[j-1]){   
                    curr[j] = 1+ prev[j-1];
                }else{
                    curr[j]= max( curr[j-1] , prev[j]);
                }
            }
            prev = curr;  
        }
        return prev[m];
    }

public:
    int longestPalindromeSubseq(string s) {

        /*MEMOIZATION
        int m= s.length();
        string t  = s;
        reverse(t.begin() ,t.end());

        vector<vector<int>> dp( m , vector<int>(m,-1));
        return memo(m-1 , m-1 , s ,t , dp);
        */
        /*TABULATION
        return tabulation( s);
        */
        return spaceOptimised(s);
    }
};
