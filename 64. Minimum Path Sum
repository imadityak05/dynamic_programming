<-- Problem Statement-->
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.


code:

class Solution {
    int memo(int i , int j , vector<vector<int>>& grid , vector<vector<int>>& dp){
        if(i==0 && j==0) return grid[0][0];
        if(i<0 || j<0) return INT_MAX;
        if(dp[i][j]!=-1) return dp[i][j];
        int up=memo(i , j-1 , grid , dp);
        int left= memo(i-1 , j , grid , dp );
        return dp[i][j] = min(up , left)+ grid[i][j];
    }
    int tab(vector<vector<int>>& grid){
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>>dp(m , vector<int>(n , 0));
        //dp[i][j] will store the  possible minimum path sum for coming upto the (i , j )th cell

        dp[0][0]= grid[0][0];

        // initialization of table

        for(int i=1;i<m;i++){
            dp[i][0]= dp[i-1][0]+ grid[i][0];
        }
        for(int j=1;j<n;j++){
            dp[0][j]= grid[0][j]+ dp[0][j-1];
        }

        // fill the table
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]= grid[i][j]+ min(dp[i-1][j] , dp[i][j-1]);
            }
        }
     return dp[m-1][n-1];
    }
public:
    int minPathSum(vector<vector<int>>& grid) {
        /*
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>>dp(m , vector<int>(n ,-1));
        return memo(m-1 , n-1 ,grid , dp);
        */
        return tab(grid);

    }
};
